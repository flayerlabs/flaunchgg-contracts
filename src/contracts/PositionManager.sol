// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {SafeTransferLib} from '@solady/utils/SafeTransferLib.sol';

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import {BalanceDelta} from '@uniswap/v4-core/src/types/BalanceDelta.sol';
import {BeforeSwapDelta, BeforeSwapDeltaLibrary, toBeforeSwapDelta} from '@uniswap/v4-core/src/types/BeforeSwapDelta.sol';
import {Currency} from '@uniswap/v4-core/src/types/Currency.sol';
import {Hooks, IHooks} from '@uniswap/v4-core/src/libraries/Hooks.sol';
import {IPoolManager} from '@uniswap/v4-core/src/interfaces/IPoolManager.sol';
import {PoolId, PoolIdLibrary} from '@uniswap/v4-core/src/types/PoolId.sol';
import {PoolKey} from '@uniswap/v4-core/src/types/PoolKey.sol';
import {SafeCast} from '@uniswap/v4-core/src/libraries/SafeCast.sol';
import {StateLibrary} from '@uniswap/v4-core/src/libraries/StateLibrary.sol';

import {BaseHook} from '@uniswap-periphery/base/hooks/BaseHook.sol';

import {BidWall} from '@flaunch/bidwall/BidWall.sol';
import {CurrencySettler} from '@flaunch/libraries/CurrencySettler.sol';
import {FairLaunch} from '@flaunch/hooks/FairLaunch.sol';
import {FeeDistributor} from '@flaunch/hooks/FeeDistributor.sol';
import {FeeExemptions} from '@flaunch/hooks/FeeExemptions.sol';
import {InternalSwapPool} from '@flaunch/hooks/InternalSwapPool.sol';
import {MemecoinFinder} from '@flaunch/types/MemecoinFinder.sol';
import {MemecoinTreasury} from '@flaunch/treasury/MemecoinTreasury.sol';
import {Notifier} from '@flaunch/hooks/Notifier.sol';
import {StoreKeys} from '@flaunch/types/StoreKeys.sol';
import {TreasuryActionManager} from '@flaunch/treasury/ActionManager.sol';
import {UniswapHookEvents} from '@flaunch/libraries/UniswapHookEvents.sol';

import {IFeeCalculator} from '@flaunch-interfaces/IFeeCalculator.sol';
import {IFlaunch} from '@flaunch-interfaces/IFlaunch.sol';
import {IInitialPrice} from '@flaunch-interfaces/IInitialPrice.sol';
import {IMemecoin} from '@flaunch-interfaces/IMemecoin.sol';


/**
 * The PositionManager is a Uniswap V4 hook that controls the user journey from token creation,
 * to fair launch, to ongoing swaps.
 *
 * The creator of the pool will receive an ERC721 representation of the token. The holder of
 * this token will be the recipient of any creator fees generated by the token in the pool.
 *
 * Hook interactions have aimed to be abstracted into inherited contracts to simplify both
 * functionality and readability. Specific use of each of these contracts has been denoted
 * within comments using square brackets where possible.
 */
contract PositionManager is BaseHook, FeeDistributor, InternalSwapPool, StoreKeys {

    using BeforeSwapDeltaLibrary for BeforeSwapDelta;
    using CurrencySettler for Currency;
    using PoolIdLibrary for PoolKey;
    using SafeCast for uint;
    using StateLibrary for IPoolManager;
    using MemecoinFinder for PoolKey;

    error CallerIsNotBidWall();
    error CannotBeInitializedDirectly();
    error InsufficientFlaunchFee(uint _paid, uint _required);
    error TokenNotFlaunched(uint _flaunchesAt);
    error UnknownPool(PoolId _poolId);

    /// Emitted when a Flaunch pool is created
    event PoolCreated(PoolId indexed _poolId, address _memecoin, address _memecoinTreasury, uint _tokenId, bool _currencyFlipped, uint _flaunchFee, FlaunchParams _params);

    /// Emitted when a Flaunch pool is scheduled
    event PoolScheduled(PoolId indexed _poolId, uint _flaunchesAt);

    /// Emitted when a pool swap occurs
    event PoolSwap(PoolId indexed poolId, int flAmount0, int flAmount1, int flFee0, int flFee1, int ispAmount0, int ispAmount1, int ispFee0, int ispFee1, int uniAmount0, int uniAmount1, int uniFee0, int uniFee1);

    /// Emitted after any transaction to share pool state
    event PoolStateUpdated(PoolId indexed _poolId, uint160 _sqrtPriceX96, int24 _tick, uint24 _protocolFee, uint24 _swapFee, uint128 _liquidity);

    /// Emitted when a user successfully premines their token
    event PoolPremine(PoolId indexed _poolId, int _premineAmount);

    /// Emitted when the `IInitialPrice` contract has been updated
    event InitialPriceUpdated(address _initialPrice);

    /// Emitted when the `FairLaunch` contract has burned unsold fair launch supply
    event FairLaunchBurn(PoolId indexed _poolId, uint _unsoldSupply);

    /**
     * Defines our constructor parameters.
     *
     * @member nativeToken The native ETH equivalent token used by protocol
     * @member poolManager The Uniswap V4 {PoolManager} contract
     * @member feeDistribution The default fee distribution configuration
     * @member initialPrice Set initial price calculator address
     * @member protocolOwner The EOA that will be the initial owner
     * @member protocolFeeRecipient The recipient EOA of all
     * @member flayGovernance The $FLAY token governance address
     * @member feeEscrow The {FeeEscrow} contract to be used by the PositionManager
     * @member feeExemptions The default global FeeExemption values
     * @member actionManager The {TreasuryActionManager} contract
     * @member bidWall The {BidWall} contract to be used by the PositionManager
     * @member fairLaunch The {FairLaunch} contract to be used by the PositionManager
     */
    struct ConstructorParams {
        address nativeToken;
        IPoolManager poolManager;
        FeeDistribution feeDistribution;
        IInitialPrice initialPrice;
        address protocolOwner;
        address protocolFeeRecipient;
        address flayGovernance;
        address feeEscrow;
        FeeExemptions feeExemptions;
        TreasuryActionManager actionManager;
        BidWall bidWall;
        FairLaunch fairLaunch;
    }

    /**
     * Parameters required when flaunching a new token.
     *
     * @member name Name of the token
     * @member symbol Symbol of the token
     * @member tokenUri The generated ERC721 token URI
     * @member initialTokenFairLaunch The amount of tokens to add as single sided fair launch liquidity
     * @member fairLaunchDuration The duration of the fair launch period
     * @member premineAmount The amount of tokens that the creator will buy themselves
     * @member creator The address that will receive the ERC721 ownership and premined ERC20 tokens
     * @member creatorFeeAllocation The percentage of fees the creators wants to take from the BidWall
     * @member flaunchAt The timestamp at which the token will launch
     * @member initialPriceParams The encoded parameters for the Initial Price logic
     * @member feeCalculatorParams The encoded parameters for the fee calculator
     */
    struct FlaunchParams {
        string name;
        string symbol;
        string tokenUri;
        uint initialTokenFairLaunch;
        uint fairLaunchDuration;
        uint premineAmount;
        address creator;
        uint24 creatorFeeAllocation;
        uint flaunchAt;
        bytes initialPriceParams;
        bytes feeCalculatorParams;
    }

    /// The minimum amount before a distribution is triggered
    uint public constant MIN_DISTRIBUTE_THRESHOLD = 0.001 ether;

    /// The `dEaD` address to burn our unsold memecoins to
    address public constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;

    /// The contract that will be used for flaunching tokens
    IFlaunch public flaunchContract;

    /// Our starting token sqrtPriceX96
    IInitialPrice public initialPrice;

    /// Internal storage to allow the `beforeSwap` tick value to be used in `afterSwap`
    int24 internal _beforeSwapTick;

    /// Store the address that will collect protocol fees
    address internal protocolFeeRecipient;

    /// Store the contract that will manage our Bidwall interactions
    BidWall public bidWall;

    /// The contract that handles the FairLaunch flow
    FairLaunch public fairLaunch;

    /// The contract that handles the token Treasury actions
    TreasuryActionManager public actionManager;

    /// Store the contract that will manage fee exemptions
    FeeExemptions public feeExemptions;

    /// Store our {Notifier} contract
    Notifier public notifier;

    /// Store the block timestamp when a poolId is set to launch
    mapping (PoolId _poolId => uint _flaunchTime) public flaunchesAt;

    /**
     * Initializes our {BaseHook} contract and initializes all implemented hooks.
     */
    constructor (ConstructorParams memory params)
        BaseHook(params.poolManager)
        FeeDistributor(params.nativeToken, params.feeDistribution, params.protocolOwner, params.flayGovernance, params.feeEscrow)
    {
        // Set our contract references
        initialPrice = params.initialPrice;

        // Set our protocol fee recipient
        protocolFeeRecipient = params.protocolFeeRecipient;

        // Register our FeeExemption contract
        feeExemptions = params.feeExemptions;

        // Register our BidWall contract
        bidWall = params.bidWall;

        // Register our FairLaunch logic
        fairLaunch = params.fairLaunch;

        // Register our ActionManager
        actionManager = params.actionManager;

        // Deploy our notifier
        notifier = new Notifier(params.protocolOwner);

        // Approve the BidWall to manage native token from the PositionManager
        IERC20(params.nativeToken).approve(address(bidWall), type(uint).max);
        IERC20(params.nativeToken).approve(address(fairLaunch), type(uint).max);
    }

    /**
     * Creates a new ERC20 memecoin token creating and an ERC721 that signifies ownership of the
     * flaunched collection. The token is then initialized into a UV4 pool.
     * 创建一个新的ERC20 memecoin token并创建一个ERC721，表示拥有flaunched集合的所有权。然后，token被初始化为一个UV4池。
     * The FairLaunch period will start in this call, as soon as the pool is initialized.
     * 在调用此函数时，FairLaunch期将开始，因为池在初始化时被启动。
     * @return memecoin_ The created ERC20 token address
     */
    function flaunch(FlaunchParams calldata _params) external payable returns (address memecoin_) {
        uint tokenId;
        address payable memecoinTreasury;

        // Flaunch our token 启动我们的token
        (memecoin_, memecoinTreasury, tokenId) = flaunchContract.flaunch(_params);

        // Check if our pool currency is flipped
        bool currencyFlipped = nativeToken >= memecoin_;

        // Create our Uniswap pool and store the pool key for lookups
        PoolKey memory _poolKey = PoolKey({
            currency0: Currency.wrap(!currencyFlipped ? nativeToken : memecoin_),
            currency1: Currency.wrap(currencyFlipped ? nativeToken : memecoin_),
            fee: 0,
            tickSpacing: 60,
            hooks: IHooks(address(this))
        });

        // Initialize the {MemecoinTreasury} with `PoolKey` 初始化MemecoinTreasury与`PoolKey`
        MemecoinTreasury(memecoinTreasury).initialize(payable(address(this)), address(actionManager), nativeToken, _poolKey);

        // Set the PoolKey to storage
        _poolKeys[memecoin_] = _poolKey;
        PoolId poolId = _poolKey.toId();

        // If we have a non-zero creator fee allocation, then we need to update our creator's
        // fee allocation. 如果创建者分配了非零的创作者费用，则需要更新创建者的费用分配。
        if (_params.creatorFeeAllocation != 0) {
            creatorFee[poolId] = _params.creatorFeeAllocation;
        }

        // Initialize all fee calculators attached to the pool, along with any custom parameters
        // 初始化所有附加到池的fee计算器，以及任何自定义参数
        _initializeFeeCalculators(poolId, _params.feeCalculatorParams);

        // Initialize our memecoin with the sqrtPriceX96
        // 初始化我们的memecoin与sqrtPriceX96
        int24 initialTick = poolManager.initialize(
            _poolKey,
            initialPrice.getSqrtPriceX96(msg.sender, currencyFlipped, _params.initialPriceParams)
        );

        // Check if we have an initial flaunching fee, check that enough ETH has been sent
        // 检查我们是否有初始的flaunching费用，检查是否发送了足够的ETH
        uint flaunchFee = getFlaunchingFee(_params.initialPriceParams);

        emit PoolCreated({
            _poolId: poolId,
            _memecoin: memecoin_,
            _memecoinTreasury: memecoinTreasury,
            _tokenId: tokenId,
            _currencyFlipped: currencyFlipped,
            _flaunchFee: flaunchFee,
            _params: _params
        });

        /**
         * [PREMINE] If the creator has requested tokens from their initial fair launch
         * allocation, which they can purchase in the same transaction.
         * 如果创建者请求了他们的初始公平启动分配，他们可以在同一交易中购买这些token。
         */

        if (_params.premineAmount != 0) {
            int premineAmount = _params.premineAmount.toInt256();
            assembly { tstore(poolId, premineAmount) }
        }

        /**
         * [FL] At token creation, x% of token supply is put into a one-sided position.
         * 在token创建时，x%的token供应被放入一个单边位置。
         */

        // We don't currently require any token approval to create a fair launch position, but
        // when the position closes, the {FairLaunch} contract will supply the {PoolManager}
        // with tokens from this contract.
        // 我们目前不需要任何token批准来创建一个公平启动位置，但是当位置关闭时，{FairLaunch}合同将从这个合同中提供token到{PoolManager}。
        IMemecoin(memecoin_).approve(address(fairLaunch), type(uint).max);

        // Regardless of having a fair launch, we need to call `createPosition` as this
        // instantiates our storage struct that is required for when the position is closed
        // and the tokens are moved to a Uniswap V4 liquidity position.
        // 无论是否有公平启动，我们都需要调用`createPosition`，因为这会实例化我们需要的存储结构，
        //当位置关闭时，token会被移动到一个Uniswap V4流动性位置。
        fairLaunch.createPosition({
            _poolId: poolId,
            _initialTick: initialTick,
            _flaunchesAt: _params.flaunchAt > block.timestamp ? _params.flaunchAt : block.timestamp,
            _initialTokenFairLaunch: _params.initialTokenFairLaunch,
            _fairLaunchDuration: _params.fairLaunchDuration
        });

        /**
         * [SCHEDULE] If we have a timestamp in the future, then we set our schedule mapping.
         * 如果我们在未来有一个时间戳，那么我们设置我们的schedule映射。
         */

        if (_params.flaunchAt > block.timestamp) {
            flaunchesAt[poolId] = _params.flaunchAt;
            emit PoolScheduled(poolId, _params.flaunchAt);
        } else {
            // If the `flaunchAt` timestamp has already passed, then use the current timestamp
            // 如果`flaunchAt`时间戳已经过去，那么使用当前时间戳
            flaunchesAt[poolId] = block.timestamp;
        }

        // Refund any additional ETH
        // 退还任何额外的ETH
        if (flaunchFee != 0) {
            // Check if we have insufficient value provided
            // 检查我们是否提供了不足的值
            if (msg.value < flaunchFee) {
                revert InsufficientFlaunchFee(msg.value, flaunchFee);
            }

            // Pay the flaunching fee to our fee recipient
            // 将flaunching费用支付给我们的fee recipient
            SafeTransferLib.safeTransferETH(protocolFeeRecipient, flaunchFee);
        }

        // Refund any ETH that was not required
        // 退还任何不需要的ETH
        if (msg.value > flaunchFee) {
            SafeTransferLib.safeTransferETH(msg.sender, msg.value - flaunchFee);
        }

        // After our contract is initialized, we mark our pool as initialized and emit
        // our state update to notify the UX of current prices, etc. This will include
        // optional liquidity modifications from the Fair Launch logic.
        // 在我们的合同被初始化后，我们标记我们的池为初始化，并发出我们的状态更新，通知UX当前的价格等。
        // 这可能包括公平启动逻辑的可选流动性修改。
        _emitPoolStateUpdate(poolId, IHooks.afterInitialize.selector, abi.encode(tokenId, _params));
    }

    /**
     * Returns the PoolKey mapped to the token address. If none is set then a zero value
     * will be returned for the fields.
     * 返回与token地址关联的PoolKey。如果没有设置，则将为字段返回零值。
     * @dev The easiest way to check for an empty response is `tickSpacing = 0`
     * @dev 检查空响应的最简单方法是`tickSpacing = 0`
     * @param _token The address of the ERC20 token
     * 
     * @return The corresponding {PoolKey} for the token
     * 返回对应的poolkey
     */
    function poolKey(address _token) external view returns (PoolKey memory) {
        return _poolKeys[_token];
    }

    /**
     * Defines the Uniswap V4 hooks that are used by our implementation. This will determine
     * the address that our contract **must** be deployed to for Uniswap V4. This address suffix
     * is shown in the dev comments for this function call.
     * 定义了Uniswap V4钩子，用于我们的实现。这将确定我们的合同**必须**部署到Uniswap V4的地址。
     * 这个地址后缀显示在dev注释中用于此函数调用。
     * @dev 1011 1111 0111 00 == 2FDC 表示我们实现了所有钩子，除了beforeInitialize和afterInitialize。
     */
    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: true, // Prevent initialize
            afterInitialize: false,
            beforeAddLiquidity: true, // [FairLaunch], [InternalSwapPool]
            afterAddLiquidity: true, // [EventTracking]
            beforeRemoveLiquidity: true, // FairLaunch], [InternalSwapPool]
            afterRemoveLiquidity: true, // [EventTracking]
            beforeSwap: true, // FairLaunch], [InternalSwapPool]
            afterSwap: true, // [FeeDistributor], [InternalSwapPool], [BidWall], [EventTracking]
            beforeDonate: false,
            afterDonate: true, // [EventTracking]
            beforeSwapReturnDelta: true, // [InternalSwapPool]
            afterSwapReturnDelta: true, // [FeeDistributor]
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    /**
     * The hook called before the state of a pool is initialized. Prevents external contracts
     * from initializing pools using our contract as a hook.
     * 防止外部合同使用我们的合同作为钩子来初始化池。
     * @dev As we call `poolManager.initialize` from the IHooks contract itself, we bypass this
     * hook call as therefore bypass the prevention.
     * 因为我们从IHooks合同本身调用`poolManager.initialize`，我们绕过这个钩子调用，因此绕过预防。
     */
    function beforeInitialize(address, PoolKey calldata, uint160) external view override onlyPoolManager returns (bytes4) {
        revert CannotBeInitializedDirectly();
    }

    /**
     * [FL] Handles swaps during the FairLaunch and closure of the position when it expires 在公平启动期间处理交换，并在位置过期时关闭位置
     * [ISP] Checks if we can process an internal swap ahead of the Uniswap swap. 检查我们是否可以在Uniswap交换之前处理内部交换。
     * [FD] Captures fees from the internal swap pool 从内部交换池捕获费用
     *
     * @param _sender The address calling the swap 调用交换的地址
     * @param _key The key for the pool 池的key
     * @param _params The parameters for the swap 交换的参数
     * @param _hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook 交换者传递给PoolManager的任意数据，将被传递给钩子
     *
     * @return selector_ The function selector for the hook 钩子的函数选择器
     * @return beforeSwapDelta_ The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency
     * @return swapFee_ The percentage fee applied to our swap
     */
    function beforeSwap(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.SwapParams memory _params,
        bytes calldata _hookData
    ) public override onlyPoolManager returns (
        bytes4 selector_,
        BeforeSwapDelta beforeSwapDelta_,
        uint24
    ) {
        /**
         * [SCHEDULE][PREMINE] Check if the token is scheduled to be flaunched and only
         * allow a swap to take place if there is a premine call available.
         * 检查token是否被安排在某个时间点启动，并且只有在有预挖调用可用时才允许交换。
         */

        {
            // If set, get the timestamp that the pool is scheduled to flaunch 如果设置，获取池计划启动的时间戳
            PoolId poolId = _key.toId();
            uint _flaunchesAt = flaunchesAt[poolId];
            if (_flaunchesAt != 0) {
                // If we have a schedule set for the token, then we need to make an additional
                // check to see if a premine is set, and if it's valid. The validity of a premine
                // ensures that we are in the same block and that the amount specified is the same.
                // We cannot check that the caller is the same as the `_sender` is obfuscated to
                // be the swap contract.
                // 如果池有计划启动，我们需要进行额外的检查，看看是否设置了预挖，并且如果它有效。
                // 预挖的有效性确保我们在同一个区块，并且指定的数量是相同的。
                // 我们不能检查调用者是否与`_sender`相同，因为它是被混淆的，被认为是交换合同。
                int premineAmount = _tload(PoolId.unwrap(poolId));
                if (premineAmount != 0 && _params.amountSpecified == premineAmount) {
                    emit PoolPremine(poolId, premineAmount);
                } else {
                    // If the timestamp has not yet passed, then we revert
                    if (_flaunchesAt > block.timestamp) {
                        revert TokenNotFlaunched(_flaunchesAt);
                    }

                    // Remove the schedule timestamp to prevent future checks
                    delete flaunchesAt[poolId];
                }
            }
        }

        // Check if our fair launch period hasn't ended and already been processed
        // 检查我们的公平启动期是否没有结束，并且已经处理过。
        FairLaunch.FairLaunchInfo memory fairLaunchInfo = fairLaunch.fairLaunchInfo(_key.toId());
        if (!fairLaunchInfo.closed) {
            bool nativeIsZero = nativeToken == Currency.unwrap(_key.currency0);

            /**
             * [FL] If it's not premine, and the FairLaunch window has ended, but our position is still open, then we
             * need to close the position.
             */

            PoolId poolId = _key.toId();
            if (_tload(PoolId.unwrap(poolId)) == 0 && !fairLaunch.inFairLaunchWindow(poolId)) {
                uint unsoldSupply = fairLaunchInfo.supply;
                
                // closes the fair launch position, putting remaining memecoin supply into the liquidity pool
                // minus the unsold fair launch supply, which is burned
                fairLaunch.closePosition({
                    _poolKey: _key,
                    _tokenFees: _poolFees[poolId].amount1,
                    _nativeIsZero: nativeIsZero
                });

                // burn the unsold fair launch supply
                if (unsoldSupply != 0) {
                    (nativeIsZero ? _key.currency1 : _key.currency0).transfer(BURN_ADDRESS, unsoldSupply);
                    emit FairLaunchBurn(poolId, unsoldSupply);
                }
            }
            else {

                /**
                 * [FL] If we are still in the FairLaunch window, then we need to prevent any swaps that
                 * are specified to sell the {Memecoin}.
                 */

                if (nativeIsZero != _params.zeroForOne) {
                    revert FairLaunch.CannotSellTokenDuringFairLaunch();
                }

                /**
                 * [FL] We attempt to fill the swap request from our FairLaunch position. If the
                 * swap parameters surpass the FairLaunch position, or the window has closed since
                 * the last swap, then this call will also close the position and create our new
                 * range.
                 */

                // Try to fill from FL at specific tick
                BalanceDelta fairLaunchFillDelta;
                (beforeSwapDelta_, fairLaunchFillDelta, fairLaunchInfo) = fairLaunch.fillFromPosition(_key, _params.amountSpecified, nativeIsZero);

                // Give the tokens to Uniswap V4 so that it can play good-cop and give them to the user
                _settleDelta(_key, fairLaunchFillDelta);

                /**
                 * [FD] We need to determine the amount of fees generated by our fair launch swap to
                 * capture, rather than sending the full amount to the end user.
                 */

                // We need to capture fees from our internal swap at this point
                uint swapFee = _captureAndDepositFees(_key, _params, _sender, beforeSwapDelta_.getUnspecifiedDelta(), _hookData);

                // Increment our swap
                _captureDelta(_params, TS_FL_AMOUNT0, TS_FL_AMOUNT1, beforeSwapDelta_);
                _captureDeltaSwapFee(_params, TS_FL_FEE0, TS_FL_FEE1, swapFee);

                // Increase the delta being sent back
                beforeSwapDelta_ = toBeforeSwapDelta(
                    beforeSwapDelta_.getSpecifiedDelta(),
                    beforeSwapDelta_.getUnspecifiedDelta() + swapFee.toInt128()
                );

                // A FairLaunch transaction will always facilitate purchasing Memecoin with
                // Native Token. This means that if the `amountSpecified` not negative, then we will
                // have captured the fee in Native Token and as such we need to reduce the amount of
                // revenue that we record.
                if (_params.amountSpecified >= 0 && swapFee != 0) {
                    fairLaunch.modifyRevenue(poolId, -swapFee.toInt128());
                }

                // If we have run out of tokens, then we can close the pool
                if (fairLaunchInfo.supply == 0) {
                    fairLaunch.closePosition({
                        _poolKey: _key,
                        _tokenFees: _poolFees[poolId].amount1,
                        _nativeIsZero: nativeIsZero
                    });
                }
            }
        }

        /**
         * [PREMINE] Delete our transient storage data to prevent premines ever being triggered
         * over multiple swaps. 
         * 删除我们的临时存储数据，以防止在多个交换中触发预挖。
         */

        {
            PoolId poolId = _key.toId();
            assembly {
                tstore(poolId, 0)
            }
        }

        /**
         * [ISP] We want to see if we have any token1 fee tokens that we can use to fill the swap
         * before it hits the Uniswap pool. This prevents the pool from being affected and reduced
         * gas costs. This also allows us to benefit from the Uniswap routing infrastructure.
         * 我们想要检查我们是否有任何token1费用token，我们可以用来在它到达Uniswap池之前填充交换。
         * 这防止了池受到影响和减少gas成本。这也允许我们受益于Uniswap路由基础设施。
         * This frontruns Uniswap to sell undesired token amounts from our fees into desired tokens
         * ahead of our fee distribution. This acts as a partial orderbook to remove impact against
         * our pool.
         * 这提前运行Uniswap，将我们不需要的token数量从我们的费用中出售到我们想要的token，
         * 在我们收取费用之前。这作为一个部分订单簿来减少对我们池的影响。
         */

        (uint tokenIn, uint tokenOut) = _internalSwap(poolManager, _key, _params, nativeToken == Currency.unwrap(_key.currency0));
        if (tokenIn + tokenOut != 0) {
            // Update our hook delta to reduce the upcoming swap amount to show that we have
            // already spent some of the ETH and received some of the underlying ERC20.
            BeforeSwapDelta internalBeforeSwapDelta = _params.amountSpecified >= 0
                ? toBeforeSwapDelta(-tokenOut.toInt128(), tokenIn.toInt128())
                : toBeforeSwapDelta(tokenIn.toInt128(), -tokenOut.toInt128());

            /**
             * [FD] We need to determine the amount of fees generated by our internal swap to capture,
             * rather than sending the full amount to the end user.
             */

            // We need to capture fees from our internal swap at this point
            uint swapFee = _captureAndDepositFees(_key, _params, _sender, internalBeforeSwapDelta.getUnspecifiedDelta(), _hookData);

            // Increment our swap
            _captureDelta(_params, TS_ISP_AMOUNT0, TS_ISP_AMOUNT1, internalBeforeSwapDelta);
            _captureDeltaSwapFee(_params, TS_ISP_FEE0, TS_ISP_FEE1, swapFee);

            // Increase the delta being sent back
            beforeSwapDelta_ = toBeforeSwapDelta(
                beforeSwapDelta_.getSpecifiedDelta() + internalBeforeSwapDelta.getSpecifiedDelta(),
                beforeSwapDelta_.getUnspecifiedDelta() + internalBeforeSwapDelta.getUnspecifiedDelta() + swapFee.toInt128()
            );
        }

        // Capture the beforeSwap tick value before actioning our Uniswap swap
        // 在执行我们的Uniswap交换之前，捕获beforeSwap tick值
        (, _beforeSwapTick,,) = poolManager.getSlot0(_key.toId());

        // Check if the BidWall has become stale, and allow liquidity to be extracted before a
        // threshold has been built. 检查BidWall是否变得陈旧，并在构建阈值之前允许流动性被提取。
        bidWall.checkStalePosition({
            _poolKey: _key,
            _currentTick: _beforeSwapTick,
            _nativeIsZero: nativeToken == Currency.unwrap(_key.currency0)
        });

        // Set our return selector
        // 设置我们的返回选择器
        selector_ = IHooks.beforeSwap.selector;
    }

    /**
     * [FD] Captures fees from the swap to either distribute or send to ISP 从交换中捕获费用，要么分配给我们的LP，要么发送给ISP。
     * [ISP] Once a swap has been made, we distribute fees to our LPs and emit our price update event. 一旦交换完成，我们分配费用给我们的LP，并发出我们的价格更新事件。
     * [FD] Tracks the swap for future fee calculations 跟踪交换，用于未来的费用计算。
     * [FL][BW] If Fair Launch ended then we may have an ETH to deposit into the BidWall 如果公平启动结束，我们可能有一个ETH存入BidWall。
     *
     * @param _sender The sender (or swap contract) making the call 调用者（或交换合同）。  
     * @param _key The key for the pool 池的key。
     * @param _params The parameters for the swap 交换的参数。
     * @param _delta The amount owed to the caller (positive) or owed to the pool (negative) 调用者欠的钱（正数）或池欠的钱（负数）。
     * @param _hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook 交换者传递给PoolManager的任意数据，将被传递给钩子。
     *
     * @return selector_ The function selector for the hook 钩子的函数选择器。
     * @return hookDeltaUnspecified_ The hook's delta in unspecified currency. Positive: the hook is owed/took currency, negative: the hook owes/sent currency 
     * 钩子的未指定货币的delta。正数：钩子欠的钱，负数：钩子欠的钱。
     */
    function afterSwap(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.SwapParams calldata _params,
        BalanceDelta _delta,
        bytes calldata _hookData
    ) public override onlyPoolManager returns (
        bytes4 selector_,
        int128 hookDeltaUnspecified_
    ) {
        /**
         * [FD] We need to determine the amount of fees generated by our Uniswap swap to capture,
         * 
         * rather than sending the full amount to the end user.
         * 我们需要确定我们Uniswap交换产生的费用，而不是发送全额给最终用户。
         */

        // Determine the currency that we will be taking our fee from 确定我们将会从哪个货币中收取费用
        (int128 amount0, int128 amount1) = (_delta.amount0(), _delta.amount1());
        int128 swapAmount = _params.amountSpecified < 0 == _params.zeroForOne ? amount1 : amount0;

        // Capture the swap fees and dispatch the referrer's share if set 
        // 捕获交换费用，并分发推荐人的份额（如果设置）
        uint swapFee = _captureAndDepositFees(_key, _params, _sender, swapAmount, _hookData);

        // Increment our swap 增加我们的交换
        assembly {
            tstore(TS_UNI_AMOUNT0, amount0)
            tstore(TS_UNI_AMOUNT1, amount1)
        }

        _captureDeltaSwapFee(_params, TS_UNI_FEE0, TS_UNI_FEE1, swapFee);

        /**
         * [ISP] Distribute any fees that have been converted by the swap.
         * 
         * 任何被交换转换的费用都需要分配。
         */

        _distributeFees(_key);

        /**
         * [FD] If we have a feeCalculator, then we want to track the swap data for any
         * dynamic calculations. 
         * 如果我们有一个feeCalculator，那么我们想要跟踪交换数据，用于任何动态计算。
         */

        PoolId poolId = _key.toId();

        {
            IFeeCalculator _feeCalculator = getFeeCalculator(fairLaunch.inFairLaunchWindow(poolId));
            if (address(_feeCalculator) != address(0)) {
                _feeCalculator.trackSwap(_sender, _key, _params, _delta, _hookData);
            }
        }

        // Set our return selector 设置我们的返回选择器
        hookDeltaUnspecified_ = swapFee.toInt128();

        selector_ = IHooks.afterSwap.selector;

        // Emit our compiled swap data
        _emitSwapUpdate(poolId, _sender);

        // Emit our pool state update to listeners
        _emitPoolStateUpdate(poolId, selector_, abi.encode(_sender, _params, _delta));
    }

    /**
     * [FL] Prevent liquidity modification during FairLaunch period 
     * 在公平启动期间防止流动性修改
     * [FD] Before a liquidity position is modified, we distribute fees before they can
     * 在流动性位置被修改之前，我们分配费用，这样他们就不能获得他们没有赚取的费用。
     * come in to take a share of fees that they have not earned.
     * 在他们可以获得他们没有赚取的费用之前，他们不能进来分享费用。
     *
     * @param _key The key for the pool
     *
     * @return selector_ The function selector for the hook
     */
    function beforeAddLiquidity(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.ModifyLiquidityParams calldata,
        bytes calldata
    ) public view override onlyPoolManager returns (
        bytes4 selector_
    ) {
        // [FL] If in fair launch window, we need to prevent liquidity being added
        // 如果我们在公平启动窗口中，我们需要防止流动性被添加
        _canModifyLiquidity(_key.toId(), _sender);

        selector_ = IHooks.beforeAddLiquidity.selector;
    }

    /**
     * Once a liquidity has been added, we emit our price update event.
     * 一旦流动性被添加，我们发出我们的价格更新事件。
     * @param _sender The initial msg.sender for the add liquidity call
     * @param _key The key for the pool
     * @param _delta The caller's balance delta after adding liquidity; the sum of principal delta, fees accrued, and hook delta
     * @param _feesAccrued The fees accrued since the last time fees were collected from this position
     *
     * @return selector_ The function selector for the hook
     * @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency
     */
    function afterAddLiquidity(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.ModifyLiquidityParams calldata,
        BalanceDelta _delta,
        BalanceDelta _feesAccrued,
        bytes calldata
    ) external override onlyPoolManager returns (
        bytes4 selector_,
        BalanceDelta
    ) {
        selector_ = IHooks.afterAddLiquidity.selector;

        // Emit our pool state update to listeners
        _emitPoolStateUpdate(_key.toId(), selector_, abi.encode(_sender, _delta, _feesAccrued));
    }

    /**
     * [FL] Prevent liquidity modification during FairLaunch period 
     * 在公平启动期间防止流动性修改
     * [FD] Before liquidity is removed, we distribute fees.
     * 在流动性被移除之前，我们分配费用。
     *
     * @param _key The key for the pool
     *
     * @return selector_ The function selector for the hook
     */
    function beforeRemoveLiquidity(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.ModifyLiquidityParams calldata,
        bytes calldata
    ) public view override onlyPoolManager returns (
        bytes4 selector_
    ) {
        // [FL] If in fair launch window, we need to prevent liquidity being removed
        _canModifyLiquidity(_key.toId(), _sender);

        // Set our return selector
        selector_ = IHooks.beforeRemoveLiquidity.selector;
    }

    /**
     * Once liquidity has been removed, we emit our price update event.
     * 一旦流动性被移除，我们发出我们的价格更新事件。
     * @param _sender The initial msg.sender for the remove liquidity call
     * @param _key The key for the pool
     * @param _delta The caller's balance delta after removing liquidity; the sum of principal delta, fees accrued, and hook delta
     * @param _feesAccrued The fees accrued since the last time fees were collected from this position
     *
     * @return selector_ The function selector for the hook
     */
    function afterRemoveLiquidity(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.ModifyLiquidityParams calldata,
        BalanceDelta _delta,
        BalanceDelta _feesAccrued,
        bytes calldata
    ) public override onlyPoolManager returns (bytes4 selector_, BalanceDelta) {
        selector_ = IHooks.afterRemoveLiquidity.selector;

        // Emit our pool state update to listeners
        _emitPoolStateUpdate(_key.toId(), selector_, abi.encode(_sender, _delta, _feesAccrued));
    }

    /**
     * The hook called after donate, emitting our price update event.
     * 一旦捐赠完成，我们发出我们的价格更新事件。
     * @param _sender The initial msg.sender for the donate call
     * @param _key The key for the pool
     * @param _amount0 The amount of token0 being donated
     * @param _amount1 The amount of token1 being donated
     *
     * @return selector_ The function selector for the hook
     */
    function afterDonate(address _sender, PoolKey calldata _key, uint _amount0, uint _amount1, bytes calldata) external override onlyPoolManager returns (bytes4 selector_) {
        selector_ = IHooks.afterDonate.selector;

        // Emit our pool state update to listeners
        _emitPoolStateUpdate(_key.toId(), selector_, abi.encode(_sender, _amount0, _amount1));
    }

    /**
     * Gets the ETH fee that must be paid to flaunch a token.
     * 获取启动token所需的ETH费用。
     * @return The ETH value of the fee
     */
    function getFlaunchingFee(bytes calldata _initialPriceParams) public view returns (uint) {
        return initialPrice.getFlaunchingFee(msg.sender, _initialPriceParams);
    }

    /**
     * Gets the ETH market cap for a new token that will be flaunched.
     * 获取启动token所需的ETH市场资本。
     * @return The ETH market cap value
     */
    function getFlaunchingMarketCap(bytes calldata _initialPriceParams) public view returns (uint) {
        return initialPrice.getMarketCap(_initialPriceParams);
    }

    /**
     * Allows the contract used to flaunch a new token to be updated.
     * 允许使用新token的合同被更新。
     * @param _flaunchContract The new {IFlaunch} contract address
     */
    function setFlaunch(address _flaunchContract) public onlyOwner {
        flaunchContract = IFlaunch(_flaunchContract);
    }

    /**
     * Updates the `IInitialPrice` contract address that is used during `flaunch` to calculate
     * the initial tick / sqrtPriceX96 value.
     * 更新`IInitialPrice`合同地址，用于`flaunch`期间计算初始tick / sqrtPriceX96值。
     * @param _initialPrice The contract address for the `IInitialPrice` contract
     */
    function setInitialPrice(address _initialPrice) public onlyOwner {
        initialPrice = IInitialPrice(_initialPrice);
        emit InitialPriceUpdated(_initialPrice);
    }

    /**
     * Calls for the BidWall to be closed, as this requires callback from the {PoolManager}.
     * 调用BidWall关闭，因为这需要来自{PoolManager}的回调。
     */
    function closeBidWall(PoolKey memory _key) public {
        // Ensure that the call is made by the BidWall which validates logic
        if (msg.sender != address(bidWall)) revert CallerIsNotBidWall();

        // Ensure that the PoolKey that is being closed is valid and recognised on the protocol,
        // otherwise we could processing issues and false positives in upcoming steps. We need to
        // ensure that the PoolKey is recognised (by checking the hooks address is not zero) and
        // that the PoolId matches when encoded.
        PoolKey memory storedKey = _poolKeys[address(_key.memecoin(nativeToken))];
        if (storedKey.hooks == IHooks(address(0)) || PoolId.unwrap(storedKey.toId()) != PoolId.unwrap(_key.toId())) {
            revert UnknownPool(_key.toId());
        }

        // Action our BidWall closure via the {PoolManager} unlock
        poolManager.unlock(abi.encode(_key));
    }

    /**
     * This function should only be called by the `closeBidWall` function to unlock the {PoolManager}
     * interactions for the `{BidWall}.closeBidWall` function.
     * 这个函数应该只被`closeBidWall`函数调用，以解锁{PoolManager}的交互，用于`{BidWall}.closeBidWall`函数。
     * @param _data The encoded {PoolKey} for the `closeBidWall` request
     *
     * @return bytes Empty data; nothing will be returned
     */
    function _unlockCallback(bytes calldata _data) internal override returns (bytes memory) {
        bidWall.closeBidWall(abi.decode(_data, (PoolKey)));
    }

    /**
     * Capture the fees from our swap. This could either be from an internal swap (`beforeSwap`)
     * or from the actual Uniswap swap (`afterSwap`).
     * 捕获我们的交换费用。这可以是内部交换(`beforeSwap`)或实际的Uniswap交换(`afterSwap`)。
     * @dev This is only used due to too many variables in the `beforeSwap` function
     *
     * @param _key The {PoolKey} that the swap was made against
     * @param _params The swap parameters called in the swap
     * @param _sender The sender of the swap call
     * @param _delta The balance change from the swap
     * @param _hookData Additional bytes data passed in the swap
     *
     * @return swapFee_ The fee taken from the swap
     */
    function _captureAndDepositFees(
        PoolKey calldata _key,
        IPoolManager.SwapParams memory _params,
        address _sender,
        int128 _delta,
        bytes calldata _hookData
    ) internal returns (uint swapFee_) {
        // Determine the swap fee currency based on swap parameters
        Currency swapFeeCurrency = _params.amountSpecified < 0 == _params.zeroForOne ? _key.currency1 : _key.currency0;

        // Capture our swap fees amount
        swapFee_ = _captureSwapFees({
            _poolManager: poolManager,
            _key: _key,
            _params: _params,
            _feeCalculator: getFeeCalculator(fairLaunch.inFairLaunchWindow(_key.toId())),
            _swapFeeCurrency: swapFeeCurrency,
            _swapAmount: uint128(_delta < 0 ? -_delta : _delta),
            _feeExemption: feeExemptions.feeExemption(_sender)
        });

        // If we have no swap fees, then we have nothing to process
        if (swapFee_ == 0) {
            return swapFee_;
        }

        // Check if we have a referrer set and send them the currency directly
        uint referrerFee = _distributeReferrerFees({
            _key: _key,
            _swapFeeCurrency: swapFeeCurrency,
            _swapFee: swapFee_,
            _hookData: _hookData
        });

        // Deposit the remaining fees against our pool to be either distributed to
        // others, or placed into the Internal Swap Pool to be converted into an ETH
        // equivalent token. We don't reduce the amount by referrer fees as we still
        // need to claim this from the PoolManager.
        _depositFees(
            _key,
            Currency.unwrap(swapFeeCurrency) == nativeToken ? swapFee_ - referrerFee : 0,
            Currency.unwrap(swapFeeCurrency) == nativeToken ? 0 : swapFee_ - referrerFee
        );
    }

    /**
     * We want to be able to distribute fees across our {FeeDistribution} recipients
     * when we reach a set threshold. This will only ever distribute the ETH equivalent
     * token, as the non-ETH token will be converted via the {InternalSwapPool} hook logic.
     * 我们想要能够在我们达到设置的阈值时，分配我们的费用给我们的{FeeDistribution}接收者。
     * 这将只会分配ETH等价的token，因为非ETH token将通过{InternalSwapPool}钩子逻辑转换。
     * @dev There referrer has already received their share, so they do not need to be
     * taken into account at this point.
     * 在这里，推荐人已经收到了他们的份额，所以他们不需要被考虑。
     * @param _poolKey The PoolKey reference that will have fees distributed
     */
    function _distributeFees(PoolKey memory _poolKey) internal {
        PoolId poolId = _poolKey.toId();

        // Get the amount of the native token available to distribute
        uint distributeAmount = _poolFees[poolId].amount0;

        // Ensure that the collection has sufficient fees available
        if (distributeAmount < MIN_DISTRIBUTE_THRESHOLD) return;

        // Reduce our available fees for the pool
        _poolFees[poolId].amount0 = 0;

        // Find the distribution amount across our different users. The amount that treasury
        // receives will be determined by variables throughout the distribution flow, such as
        // the BidWall being disabled, etc.
        (uint bidWallFee, uint creatorFee, uint protocolFee) = feeSplit(poolId, distributeAmount);
        uint treasuryFee;

        // Load our memecoin so that we can query the creator and treasury
        IMemecoin memecoin = _poolKey.memecoin(nativeToken);

        // Check if our creator has been burned, as this changes fee allocation in a number of places
        address poolCreator = memecoin.creator();
        bool poolCreatorBurned = poolCreator == address(0);

        if (creatorFee != 0) {
            // Ensure that the pool creator has not burned their ownership and send them the fees
            if (!poolCreatorBurned) {
                _allocateFees(poolId, poolCreator, creatorFee);
            }
            // If the pool creator has burned their ownership, then we instead send fees directly
            // to the BidWall.
            else {
                bidWallFee += creatorFee;
                creatorFee = 0;
            }
        }

        if (bidWallFee != 0) {
            // Check if we have an active BidWall for the pool. If we don't have an active BidWall, then
            // we will need to instead allocate this to the protocol. If we are still in the FairLaunch
            // window the this will just carry over into the FairLaunch created position, so we already
            // have this value attributed.
            if (bidWall.isBidWallEnabled(poolId) && !fairLaunch.inFairLaunchWindow(poolId)) {
                // Otherwise, we can deposit directly into the BidWall as we have permission to modify
                // liquidity outside of the window.
                bidWall.deposit(_poolKey, bidWallFee, _beforeSwapTick, nativeToken == Currency.unwrap(_poolKey.currency0));
            } else {
                // If we cannot import into BidWall, then treasury will be allocated the fees
                treasuryFee += bidWallFee;
                bidWallFee = 0;
            }
        }

        if (treasuryFee != 0) {
            // Ensure that the pool creator has not burned their ownership and send treasury the fees
            if (!poolCreatorBurned) {
                _allocateFees(poolId, memecoin.treasury(), treasuryFee);
            } else {
                // If we cannot allocate to treasury, then protocol receives the fees
                protocolFee += treasuryFee;
                treasuryFee = 0;
            }
        }

        // Finally we allocate our protocol fees
        if (protocolFee != 0) {
            _allocateFees(poolId, protocolFeeRecipient, protocolFee);
        }

        emit PoolFeesDistributed(poolId, distributeAmount, creatorFee, bidWallFee, treasuryFee, protocolFee);
    }

    /**
     * Using the `tstore` values that we have generated along the way, we emit an event that shows
     * the breakdown of fees earned at each swap point.
     * 使用我们沿途生成的`tstore`值，我们发出一个事件，显示每个交换点赚取的费用的 breakdown。
     * @param _poolId The PoolId that is being emitted
     * @param _sender The router of the swap
     */
    function _emitSwapUpdate(PoolId _poolId, address _sender) internal {
        // Emit our protocol-recognised event
        emit PoolSwap(
            _poolId,
            _tload(TS_FL_AMOUNT0), _tload(TS_FL_AMOUNT1), _tload(TS_FL_FEE0), _tload(TS_FL_FEE1),
            _tload(TS_ISP_AMOUNT0), _tload(TS_ISP_AMOUNT1), _tload(TS_ISP_FEE0), _tload(TS_ISP_FEE1),
            _tload(TS_UNI_AMOUNT0), _tload(TS_UNI_AMOUNT1), _tload(TS_UNI_FEE0), _tload(TS_UNI_FEE1)
        );

        // Emit the Uniswap V4 standardised event
        UniswapHookEvents.emitHookSwapEvent({
            _poolId: _poolId,
            _sender: _sender,
            _amount0: _tload(TS_FL_AMOUNT0) + _tload(TS_ISP_AMOUNT0),
            _amount1: _tload(TS_FL_AMOUNT1) + _tload(TS_ISP_AMOUNT1),
            _fee0: _tload(TS_FL_FEE0) + _tload(TS_ISP_FEE0),
            _fee1: _tload(TS_FL_FEE1) + _tload(TS_ISP_FEE1)
        });

        // @dev We flush the tstore values at this point as although they are only set
        // explicitly and not modified, both the FL and ISP could be bypassed but the tstore
        // data would remain.

        assembly {
            tstore(TS_FL_AMOUNT0, 0)
            tstore(TS_FL_AMOUNT1, 0)
            tstore(TS_FL_FEE0, 0)
            tstore(TS_FL_FEE1, 0)
            tstore(TS_ISP_AMOUNT0, 0)
            tstore(TS_ISP_AMOUNT1, 0)
            tstore(TS_ISP_FEE0, 0)
            tstore(TS_ISP_FEE1, 0)
            tstore(TS_UNI_AMOUNT0, 0)
            tstore(TS_UNI_AMOUNT1, 0)
            tstore(TS_UNI_FEE0, 0)
            tstore(TS_UNI_FEE1, 0)
        }
    }

    /**
     * Emits an event that provides pool state updates and passes the data to subscribers.
     * 发出一个事件，提供池状态更新，并传递数据给订阅者。
     * @param _poolId The PoolId that has been updated
     * @param _key The selector being sent to notification subscribers
     * @param _data The data being sent to notification subscribers
     */
    function _emitPoolStateUpdate(PoolId _poolId, bytes4 _key, bytes memory _data) internal {
        // Notify our subscribed contracts
        notifier.notifySubscribers(_poolId, _key, _data);

        // Emit our event
        (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 swapFee) = poolManager.getSlot0(_poolId);
        emit PoolStateUpdated(_poolId, sqrtPriceX96, tick, protocolFee, swapFee, poolManager.getLiquidity(_poolId));
    }

    /**
     * Settles tokens against the PoolManager based on the BalanceDelta passed.
     * 根据传递的BalanceDelta，结算token与PoolManager。
     * @dev This is required to be separated due to Stack Too Deep errors
     *
     * @param _poolKey The pool key to settle against
     * @param _delta The BalanceDelta showing token amounts to settle
     */
    function _settleDelta(PoolKey memory _poolKey, BalanceDelta _delta) internal {
        if (_delta.amount0() < 0) {
            _poolKey.currency0.settle(poolManager, address(this), uint(-int(_delta.amount0())), false);
        } else if (_delta.amount0() > 0) {
            poolManager.take(_poolKey.currency0, address(this), uint(int(_delta.amount0())));
        }

        if (_delta.amount1() < 0) {
            _poolKey.currency1.settle(poolManager, address(this), uint(-int(_delta.amount1())), false);
        } else if (_delta.amount1() > 0) {
            poolManager.take(_poolKey.currency1, address(this), uint(int(_delta.amount1())));
        }
    }

    /**
     * We need to be able to set the (un)specified token to amount0 / amount1 for the expected
     * event emit format.
     * 我们需要能够设置(未指定)token为amount0 / amount1，用于预期的事件emit格式。
     * @param _params The `SwapParams` used to capture the delta
     * @param _key_amount0 The tstore key for the token0 amount
     * @param _key_amount1 The tstore key for the token1 amount
     * @param _delta The `BeforeSwapDelta` that is being captured
     */
    function _captureDelta(
        IPoolManager.SwapParams memory _params,
        bytes32 _key_amount0,
        bytes32 _key_amount1,
        BeforeSwapDelta _delta
    ) internal {
        (int token0, int token1) = _params.amountSpecified < 0 == _params.zeroForOne
            ? (-_delta.getSpecifiedDelta(), -_delta.getUnspecifiedDelta())
            : (-_delta.getUnspecifiedDelta(), -_delta.getSpecifiedDelta());

        // Store our amounts
        assembly {
            tstore(_key_amount0, token0)
            tstore(_key_amount1, token1)
        }
    }

    /**
     * Maps our swap fee to the expected event emit format.
     * 我们需要能够设置(未指定)token为amount0 / amount1，用于预期的事件emit格式。
     * @param _params The `SwapParams` used to capture the delta
     * @param _key_fee0 The tstore key for the token0 fee amount
     * @param _key_fee1 The tstore key for the token1 fee amount
     * @param _delta The `uint` that is being captured for the fee
     */
    function _captureDeltaSwapFee(
        IPoolManager.SwapParams memory _params,
        bytes32 _key_fee0,
        bytes32 _key_fee1,
        uint _delta
    ) internal {
        // The delta provided needs to be made negative
        int delta = -int(_delta);

        if (_params.amountSpecified < 0 == _params.zeroForOne) {
            assembly {
                tstore(_key_fee0, 0)
                tstore(_key_fee1, delta)
            }
        } else {
            assembly {
                tstore(_key_fee0, delta)
                tstore(_key_fee1, 0)
            }
        }
    }

    /**
     * If in fair launch window, we need to prevent liquidity being added. We can, however, modify
     * liquidity if we are making the call from the BidWall or FairLaunch contracts.
     * 如果我们在公平启动窗口中，我们需要防止流动性被添加。然而，如果我们从BidWall或FairLaunch合同调用，我们可以修改流动性。
     * @param _poolId The PoolId having the liquidity modified
     * @param _sender The address that is trying to modify liquidity
     */
    function _canModifyLiquidity(PoolId _poolId, address _sender) internal view {
        // Check our valid addresses
        if (_sender == address(bidWall) || _sender == address(fairLaunch)) {
            return;
        }

        // Check if we have exited the FairLaunch window
        if (!fairLaunch.inFairLaunchWindow(_poolId)) {
            return;
        }

        // All other scenarios will result in revert
        revert FairLaunch.CannotModifyLiquidityDuringFairLaunch();
    }

    /**
     * Helper function to allow for tstore-d variables to be called individually. This saves us
     * 允许单独调用tstore-d变量。这节省了我们定义一个额外的变量，在我们`tload`调用之前。
     * defining an additional variable before our `tload` calls inside the function.
     * 在我们函数内部的`tload`调用之前，定义一个额外的变量。
     * @param _key The `tstore` key to load
     * 加载`tstore`键的值。
     * @return value_ The `int` value in the tstore
     */
    function _tload(bytes32 _key) internal view returns (int value_) {
        assembly { value_ := tload(_key) }
    }

    /**
     * Override to return true to make `_initializeOwner` prevent double-initialization.
     * 重写以返回true，使`_initializeOwner`防止双重初始化。
     * @return bool Set to `true` to prevent owner being reinitialized.
     */
    function _guardInitializeOwner() internal pure override returns (bool) {
        return true;
    }

}
